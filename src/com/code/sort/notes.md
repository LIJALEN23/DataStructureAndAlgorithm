# 排序算法(sort)
## 冒泡排序(bubble sort)
- 算法：从第一个元素开始遍历未排序的元素(遍历一次则必有一个元素到数组的末尾正确位置)，对比两个相邻的元素(未排序则交换两个元素的位置)。
- 优化：第一次遍历整个数组时未发生交换，则数组已排序，无需在继续遍历

## 选择排序(select sort)
- 算法：每次遍历未排序的部分找到最小元素，并进行相应交换

## 插入排序(insert sort)
- 算法：将未排序的元素中依次插入已排序的数组中，在已排序的数组中寻找位置(可以用二分查找寻找位置优化)

## 希尔排序(shell sort)

- 算法：利用插入排序的思想，但是通过增量将整个数组进行分区插入排序，使插入排序对相对有序的数组排序更快。

- 增量的选择对于Shell Sort的性能至关重要，不同的增量序列可能导致不同的时间复杂度。以下是一些常见的增量序列选择方法：

  1. **原始希尔增量**：这是希尔最初提出的增量序列，形式为 `h = 2 * h + 1`，从1开始计算，直到超过数组长度的一半为止。例如，对于长度为n的数组，可能的增量序列是 `[1, 3, 7, 15, ..., <n/2]`。
  2. **希拉尔增量**：这个序列是由Hibbard提出的，形式为 `h = 2 * h + 1` 但只取那些使得 `2^k - 1` 的值。例如，对于长度为n的数组，可能的增量序列是 `[1, 3, 7, 15, 31, ...]`，直到 `< n`。
  3. **Sedgewick增量**：这是由Sedgewick提出的优化版本，形式为 `9 * (9 * i - 4) / 2` 和 `9 * (9 * i - 2) / 2`。例如，可能的增量序列是 `[1, 4, 10, 23, 57, 132, 301, 701, ...]`。
  4. **Knuth增量**：这是由Donald Knuth提出的增量序列，形式为 `h = 3 * h + 1`，从1开始计算，直到超过数组长度的一半为止。例如，可能的增量序列是 `[1, 4, 13, 40, 121, ...]`，直到 `< n`。

  这些序列各有优缺点，在实际应用中可以根据具体情况选择合适的增量序列。通常情况下，Knuth增量序列由于其实现简单且表现良好而被广泛采用。Sedgewick增量则可以进一步提高效率，尤其是在大数据集上。

## 归并排序(merge sort)
## 快速排序(quick sort)
## 堆排序(heap sort)
## 计数排序(count sort)
## 基数排序(cardinality sort)
## 桶排序(bucket sort)