# 排序算法(sort)
## 冒泡排序(bubble sort)
- 算法：从第一个元素开始遍历未排序的元素(遍历一次则必有一个元素到数组的末尾正确位置)，对比两个相邻的元素(未排序则交换两个元素的位置)。
- 优化：第一次遍历整个数组时未发生交换，则数组已排序，无需在继续遍历

## 选择排序(select sort)
- 算法：每次遍历未排序的部分找到最小元素，并进行相应交换

## 插入排序(insert sort)
- 算法：将未排序的元素中依次插入已排序的数组中，在已排序的数组中寻找位置(可以用二分查找寻找位置优化)

## 希尔排序(shell sort)

- 算法：利用插入排序的思想，但是通过增量将整个数组进行分区插入排序，使插入排序对相对有序的数组排序更快。

- 增量的选择对于Shell Sort的性能至关重要，不同的增量序列可能导致不同的时间复杂度。以下是一些常见的增量序列选择方法：

  1. **原始希尔增量**：这是希尔最初提出的增量序列，形式为 `h = 2 * h + 1`，从1开始计算，直到超过数组长度的一半为止。例如，对于长度为n的数组，可能的增量序列是 `[1, 3, 7, 15, ..., <n/2]`。
  2. **希拉尔增量**：这个序列是由Hibbard提出的，形式为 `h = 2 * h + 1` 但只取那些使得 `2^k - 1` 的值。例如，对于长度为n的数组，可能的增量序列是 `[1, 3, 7, 15, 31, ...]`，直到 `< n`。
  3. **Sedgewick增量**：这是由Sedgewick提出的优化版本，形式为 `9 * (9 * i - 4) / 2` 和 `9 * (9 * i - 2) / 2`。例如，可能的增量序列是 `[1, 4, 10, 23, 57, 132, 301, 701, ...]`。
  4. **Knuth增量**：这是由Donald Knuth提出的增量序列，形式为 `h = 3 * h + 1`，从1开始计算，直到超过数组长度的一半为止。例如，可能的增量序列是 `[1, 4, 13, 40, 121, ...]`，直到 `< n`。

  这些序列各有优缺点，在实际应用中可以根据具体情况选择合适的增量序列。通常情况下，Knuth增量序列由于其实现简单且表现良好而被广泛采用。Sedgewick增量则可以进一步提高效率，尤其是在大数据集上。

## 归并排序(merge sort)

- 算法：采用分治法（Divide and Conquer）的策略来实现。归并排序的基本思想是将数组分成两半，分别对每一半进行排序，然后再将两个已排序的子数组合并成一个完整的有序数组。
  1. 自底向上：通过间隔的量(1, 2, 4, 8.....)来分割子数组进行归并
  2. 自顶向下：递归的将数组分为只有一个或者两个元素时进行合并

## 快速排序(quick sort)
- 算法：通过切分选取一个切分元素，将其两边的元素进行排序。然后再递归调用。
- 优化：1. 运用插入排序 2. 三等分切分

## 堆排序(heap sort)
堆排序（Heap Sort）是一种基于比较的排序算法，它利用了二叉堆的数据结构特性。堆排序并不直接等同于构建一个优先队列然后按优先级放入数组中，但两者之间有密切的关系。下面是堆排序的基本步骤：
- 算法：
  1. **构建最大堆/最小堆**：将给定的无序数组构建成一个最大堆（或最小堆），在这个过程中，最大的（或最小的）元素将位于堆的根节点上。
  2. **排序输出**：
     - 从堆中移除根节点上的元素（这是当前堆中的最大值或最小值），将其放到数组的一端。
     - 调整剩余元素，使其重新满足堆的性质。
     - 重复上述过程，直到所有元素都被移除并正确排序。

## 计数排序(count sort)
## 基数排序(cardinality sort)
## 桶排序(bucket sort)