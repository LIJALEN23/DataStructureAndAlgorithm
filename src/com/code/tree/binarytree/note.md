# 二叉树

## 1二叉搜索树
二叉搜索树（Binary Search Tree），也称为有序二叉树或排序二叉树，是一种特殊的二叉树数据结构。它的每个节点最多有两个子节点，并且具有以下特性：

1. **左子树**：任何节点的左子树只包含键值小于该节点键值的节点。
2. **右子树**：任何节点的右子树只包含键值大于该节点键值的节点。
3. **唯一性**：树中没有键值相同的节点。

这些属性使得在二叉搜索树中查找、插入和删除操作都非常高效，尤其是在平衡的二叉搜索树中，这些操作的时间复杂度可以达到 O(log n)。

### 二叉搜索树的基本操作包括：
- **查找**：从根节点开始，如果要查找的键值小于当前节点的键值，则进入左子树；如果大于，则进入右子树；如果相等，则找到了目标节点。
- **插入**：类似于查找过程，如果树中不存在与要插入的键值相同的节点，则根据键值的大小将新节点添加到合适的位置。
- **删除**：删除一个节点时，需要考虑三种情况：
  - 要删除的节点是叶子节点（无子节点）。
  - 要删除的节点只有一个子节点。
  - 要删除的节点有两个子节点。此时需要找到该节点的后继节点（右子树中的最小节点）或前驱节点（左子树中的最大节点），用其替换要删除的节点，然后删除该后继或前驱节点。

### 优点：
- 快速查找、插入和删除。
- 可以方便地实现有序遍历（如中序遍历可以得到排序后的结果）。

### 缺点：
- 在最坏的情况下（例如当树完全不平衡时，退化为链表），效率会降低至 O(n)。

为了保持较高的性能，实际应用中经常使用自平衡二叉搜索树，比如 AVL 树和红黑树等，它们通过自动调整来保持树的高度尽可能小，从而保证操作的时间复杂度接近 O(log n)。

---

## 2AVL树
AVL树是一种自平衡的二叉搜索树，它由苏联计算机科学家G.M. Adelson-Velsky和E.M. Landis在1962年发明。AVL树的主要特点是它能够自动维持自身的平衡状态，确保树的高度保持在一个较低的水平，从而提高查找、插入和删除操作的效率。

### AVL树的特点：

1. **平衡条件**：AVL树中任意节点的左子树和右子树的高度差不超过1（即平衡因子的绝对值不大于1）。这里的“高度”是指从某个节点到最远叶子节点的最长路径上的边数。

2. **自平衡机制**：当向AVL树中插入或删除节点导致树失去平衡时，AVL树会通过一系列的旋转操作来恢复平衡。这些旋转包括单旋转（LL旋转、RR旋转）和双旋转（LR旋转、RL旋转）。

> AVL和红黑树不一样，AVL树用的是递归方法实现的

### AVL树的基本操作：

- **插入**：插入操作与普通二叉搜索树相似，但当插入导致树失去平衡时，需要进行旋转操作来恢复平衡。
- **删除**：删除操作同样先执行普通二叉搜索树的删除操作，之后检查是否破坏了平衡条件，如果破坏则进行旋转操作以恢复平衡。
- **查找**：查找操作与普通二叉搜索树相同，但由于AVL树的高度被限制在较低水平，因此查找效率较高。

### 旋转操作：

1. **单旋转**：
   - LL旋转：当节点的左子树比右子树高，并且新插入节点在左子树的左侧时。
   - RR旋转：当节点的右子树比左子树高，并且新插入节点在右子树的右侧时。
   
2. **双旋转**：
   - LR旋转：当节点的左子树比右子树高，但新插入节点在左子树的右侧时，先对左子树做一次RR旋转，再对原节点做一次LL旋转。
   - RL旋转：当节点的右子树比左子树高，但新插入节点在右子树的左侧时，先对右子树做一次LL旋转，再对原节点做一次RR旋转。

### 性能分析：

- **时间复杂度**：AVL树的所有基本操作（查找、插入、删除）的时间复杂度都是O(log n)，其中n是树中的节点数量。
- **空间复杂度**：AVL树的空间复杂度是O(n)，因为每个节点都需要存储相应的数据。

AVL树非常适合于需要频繁执行查找操作并且对树的高度保持敏感的应用场景，例如数据库索引和其他需要快速查找的数据结构。

---

## 3红黑树

红黑树（Red-Black Tree）是一种自平衡的二叉搜索树，它是计算机科学中常用的一种数据结构。红黑树在插入和删除操作后能够自动调整自身以保持平衡，从而确保所有操作（查找、插入、删除）的时间复杂度为 O(log n)，其中 n 是树中节点的数量。

### 红黑树的性质：

1. **节点颜色**：每个节点被标记为红色（red）或黑色（black）。
2. **根节点**：根节点必须是黑色。
3. **叶子节点**：所有叶子节点（null或空节点）都是黑色。
4. **红色节点**：没有两个连续的红色节点，即一个红色节点不能有红色的父节点。
5. **黑色节点数**：从任一节点到其每个叶子节点的所有简单路径上，包含相同数量的黑色节点。

左根右、根叶黑、不红红、黑路同

> 红黑树的操作一般是用迭代的方式实现的

### 插入操作：

在插入新节点时，通常将**新节点标记为红色**，这样不会立即违反红黑树的性质4（没有连续的红色节点）。然后通过一系列的重新着色和旋转操作来恢复红黑树的平衡。

### 删除操作：

删除操作可能会破坏红黑树的性质，因此需要通过重新着色和旋转来重新平衡树。

### 旋转操作：

1. **左旋**（Left Rotation）：将一个节点作为中心，将其右子树旋转到左边，成为该节点的新子树。
2. **右旋**（Right Rotation）：将一个节点作为中心，将其左子树旋转到右边，成为该节点的新子树。

### 平衡操作：

红黑树通过以下几种方式进行平衡操作：
- **重新着色**：改变节点的颜色。
- **旋转**：进行左旋或右旋。
- **组合操作**：可能需要多次重新着色和旋转的组合来恢复平衡。

### 应用场景：

由于红黑树具有较好的平衡性和较低的时间复杂度，它被广泛应用于各种场景，特别是需要维护有序集合或映射（关联数组）的地方。例如，在GNU C++标准模板库（STL）中，`std::map`和`std::set`容器就是基于红黑树实现的。

### 与AVL树的比较：

虽然红黑树和AVL树都是自平衡二叉搜索树，但是它们在平衡策略上有区别。AVL树要求任意节点的左右子树高度差不超过1，这使得AVL树的高度更加严格地控制，但也可能导致更多的旋转操作。相比之下，红黑树的平衡策略更宽松一些，允许更高的树高，但在实践中往往提供更好的平均性能，尤其是在频繁插入和删除的场景下。
