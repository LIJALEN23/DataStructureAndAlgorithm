# Hashing(散列)
特点：通过映射的方式实现时间复杂度为O(1)的查找，删除，插入
- 以空间换时间，所以提高哈希表的空间利用率是个优化方式

## 术语
- **散列(hashing)**：无需执行搜索即可通过键得到的索引来获取值的技术
- **散列表(hash table)**：储存了值得*数组*
- **散列函数(hash function)**：将键映射到散列表中的索引上的函数
- **完美散列函数(perfect hash function)**：每个搜索键都有一个不重复的索引，即不产生冲突
- **冲突(collision)**：两个不同的键通过散列函数算出了相同的索引值

## 实现散列函数
典型的散列函数
1. 首先将*搜索键*转化成一个称为*散列码*的整数值
2. 再将散列码压缩为散列表中的*索引*
### 基本数据类型的散列码
- **整型**：每个整数对应相应的唯一的散列码
- **浮点型**：根据浮点数唯一的二级制位转化为唯一的整数，再得出散列码
- **long与double**：long先通过折叠(folding：将前32位和后32位进行异或操作结合)。double先设计算法转化为long，再对long进行处理
### 字符串的散列码
基本思想：将所有字符对应的Unicode求和作为散列码
1. **求散列码**：多项式散列码法(polynomial hash code)和Horner规则，避免字符串太长溢出。
2. **压缩散列码**：散列码可能太大了超过了索引范围，所以要进行压缩操作。理想情况下应该选一个素数来保证索引均匀展开(素数太大了会很耗时)
```C
index = hashCode(str) % N;
```
- 一个优化办法：N设置为2的整数次幂，通过&操作符来进行压缩
```C
index = hashCode(str) & (N - 1)
```

## 处理冲突分类
当两个键映射到散列表的同一个索引上，会产生冲突
### 开放地址法
开放地址法：在冲突发生时，在散列表中找到一个开放位置的过程(仅仅只在这个数组中寻找空的位置)
- **线性探测法(linear probing)**：按顺序查找下一个可用位置(这个不行看下一个)
  - 缺点：当散列表中的一个连续单元被占用时，会放慢查找时间
- **二次探测法(quadratic probing)**：不是线性的连续，而是1 4 9....(这个不行看下N的平方个)
  - 缺点：线性探测法能探测只要存在空的单元那么就能成功插入，而二次探测法不能保证
- **双重散列法**：在运用键上的第二个h(key) + n * h'(key)来确定增量

### 分离链接法
分析链接法：将两个具有同一个散列索引的条目放在同一个位置(通过链表+数组实现一个桶)
 - 问题：搜索时间复杂度变了

## 实现思想分类
1. **直接寻址表 (Direct Addressing Table)**：
   - 适用于关键字范围较小且稠密的情况。
   - 使用一个直接寻址数组，其中每个数组下标对应一个关键字，数组的值存储对应的元素。
   - 优点：查找速度非常快，插入和删除操作时间复杂度为O(1)。
   - 缺点：空间复杂度较高，不适用于关键字范围大且稀疏的情况。

2. **哈希表 (Hash Table)**：
   - 使用哈希函数将关键字映射到哈希表中的位置（桶）。
   - 解决冲突的方法主要有两种：开放地址法和链地址法。
   
   - **开放地址法 (Open Addressing)**：
     - 当冲突发生时，利用探查策略在哈希表中寻找下一个空闲位置。
     - 常见的探查策略有线性探查、二次探查和双重哈希。
     - 优点：不需要额外的指针或链表结构，适合小规模的数据集。
     - 缺点：表的负载因子（存储元素的数量与表大小的比值）不能太高，否则性能下降。

     - **线性探查 (Linear Probing)**：
       - 当冲突发生时，按顺序查找下一个空闲位置。
       - 缺点是容易产生“堆积”现象，即多个冲突元素集中在一起，导致查找效率下降。
     
     - **二次探查 (Quadratic Probing)**：
       - 当冲突发生时，根据二次函数计算下一个空闲位置。
       - 比线性探查更好地解决堆积问题，但存在二次探查失败的可能性。

     - **双重哈希 (Double Hashing)**：
       - 使用两个不同的哈希函数，当冲突发生时，使用第二个哈希函数计算新的位置。
       - 进一步减少堆积问题，适用于高负载因子的情况。

   - **链地址法 (Chaining)**：
     - 每个桶存储一个链表（或其他数据结构，如平衡树），所有哈希到同一个位置的元素都保存在该链表中。
     - 优点：处理冲突时效率较高，表的负载因子可以大于1。
     - 缺点：需要额外的空间存储指针。

3. **再哈希法 (Rehashing)**：
   - 当哈希表装填因子（负载因子）达到一定阈值时，创建一个更大的哈希表，并将所有元素重新哈希到新的表中。
   - 适用于需要动态调整表大小的情况，能够有效避免表的过度填充。

4. **完美哈希 (Perfect Hashing)**：
   - 使用两个层次的哈希表，其中第一层哈希表中的每个桶存储一个小型哈希表，第二层哈希表通过无冲突哈希函数实现。
   - 适用于静态数据集（数据集不发生变化），能保证O(1)的查找时间。

5. **Cuckoo Hashing**：
   - 使用两个或更多的哈希函数，每个元素在表中有两个或多个可能的位置。
   - 当插入元素时，如果某个位置已经被占用，则将原来的元素移到它的另一个可能位置，重复这一过程。
   - 适用于需要高效查找和插入的情况，但删除操作较复杂。